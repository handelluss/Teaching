#include <iostream>
using namespace std;
int main()
{
    /*
       
       тип данных bool - это точно такой же тип данных, как int,
       но с той особенностью, что он принимает только два значения:
       true (1) или false (0)
            
    */

    bool flag = true;
    cout << flag << endl;
    flag = 0;
    cout << flag << "\n\n\n";

    /*
        Для компилятора с++ одинаковый эффект имеют записи (без кавычек)
        "true" или "1" ("false" или "0")

        Более того, для компилятора значения 0 (типа int), 0.0 типа (float)
        есть ни что иное как false; в то время как ВСЕ остальные значения
        воспринимаются компилятором как true. Но я рекомендую не злоупотреблять
        тем, что true - это всё, что не ноль, поскольку снижается читаемость кода
    */

    bool flag1 = 0.0, flag2 = 10, flag3 = -256, flag4 = '1';
    cout << flag1 << " " << flag2 << " " << flag3 << " " << flag4 << "\n\n\n";


    /*
        На прошлом занятии мы рассматривали базовые арифметические операторы.
        Сейчас предлагаю рассмотреть операторы сравнения, реализованные в с++.
        Эти операторы работают точно также, как и в математике.

        Равенство   ----------  ==
        Неравенство   --------  !=
        Больше   -------------  >
        Меньше   -------------  <
        Больше или равно   ---  >=
        Меньше или равно   ---  <=
    
        Операторы сравнения - БИНАРНЫЕ операторы. Другими словами,
        необходимо ровно два операнда (умное слово для переменной 
        или значения) для корректной работы операторов сравнения.
        И это очевидно, ведь, например чтобы проверить, больше ли одно число
        другого, необходимо два числа.
    */

    int numberOne = 29, numberTwo = 30;
    cout << (numberOne == numberTwo) << endl;
    cout << (numberOne <= numberTwo) << endl;
    bool areSame = 30 == 30;
    cout << areSame << "\n\n\n";

     
    /*
        Рассмотрим логические операторы. Логические операторы работают
        с типом данных bool.
        
        Дизъюнкция (логическое сложение) -----  || 
        Конъюнкция (логическое умножение) ----  &&
        НЕ (логическое отрицание) ------------  !
    
        Замечу, что логические операторы, ровно как и
        операторы сравнения, являются бинарными операторами. 
        Логические операторы работают точно также, как и на уроках информатики.

        Оператор НЕ меняет значение с true на false и наоборот.
        Дизъюнкция истинна тогда и только тогда, когда хотя бы один операнд истинен.
        Конъюнция истинна тогда и только тогда, когда оба операнда истинны.


        Arg1    Arg2    ||  &&
        0       0       0   0
        0       1       1   0  
        1       0       1   0
        1       1       1   1

    */

    flag1 = true; flag2 = false;
    cout << !flag1 << " " << !flag2 << endl;
    cout << (flag1 || flag2) << " " << (flag1 && flag2) << endl;

    bool a = (!((true && false) || true)) && true; 
    cout << a << "\n\n\n"; // разберитесь, почему выводиться в компилятор false

    /*
        Ровно как и во всех языках программирования, в С++ существуют
        Условные Операторы. Другими словами, if и else.

        P.S. Они называются условными, поскольку в них есть условие


        if(какое-либо условие){
            блок кода
        }
        else {
            блок кода
        }
        
        Под условием имеется ввиду тип данных bool - это может
        быть переменная типа данных bool, логическое выражение,
        сравнение чисел.
        Под блоком кода понимается просто набор команд.

        Важный момент: если в "блоке кода" будет находиться
        лишь одна команда, то достаточно просто написать эту
        команду без фигурных скобок, но учтите, что рекомендуется
        писать без фигурных скобок лишь тогда, когда на 100%
        уверены, что в будущем более чем одной команды в "блоке кода"
        не будет.

        if(условие)
            команда;
        else(условие)
            команда;
    */
    
    // напишем программу для сравнения двух чисел:

    int numOne, numTwo; cin >> numOne >> numTwo;
    if (numOne > numTwo) 
        cout << "First number is greater\n\n\n";
    else
        cout << "Second number is greater\n\n\n";
    /*
        Примечательно, что для чисел одинаковых данная
        программа работает некорректно. Можете убедиться
        в этом сами.
        Для решения этой проблемы существует 
        конструкция else if(условие).
    */

    if (numOne > numTwo) {
        cout << "First number is greater\n\n\n";
    }
    else if (numOne < numTwo) {
        cout << "Second number is greater\n\n\n";
    }
    else {
        cout << "They are the same\n\n\n";
    }
    /*
        Замечу, что необязательно использовать и else if,
        и else: от них можно отказаться. Более того,
        else if можно использовать сколько-угодно раз
    */
 


    /*
        Программисты - существа ленивые. Поэтому
        в языке С++ реализованы сокращённые 
        арифметические операторы.
        Запись "number = number + 10" можно сократить до
        "number += 10"
        Ситуация ровно такая же, как и с -, *, /, %.
    */
    
    int var1 = 10, var2 = 5;
    var1 += var2 + 10; // то же самое, что var1 = var1 + var2 + 10
    cout << var1 << "\n\n\n";

   /*
       На самом деле, программисты ооочень ленивые. Очень
       часто придётся прибавлять или вычитать из числа единицу.
       Для этого существует Унарный оператор (то есть, работает
       с одним операндом) Инкремента и Декремента
   */

    var1 = 10; var2 = 5;
    var1--; ++var2;
    cout << var1 << " " << var2 << endl;

    /*
        Как видно на примере выше, существует постфиксная или
        префиксная запись инкремента (декремента). 
        Разница между ними ну очень интересная.
        Сравните примеры ниже.
    */

    var1 = 10; var2 = 5;
    cout << var1-- << " " << ++var2 << endl;

    /*
        Разница между постфиксной и префиксной формой записи
        в том, что префиксный ин(де)кремент выполняется перед
        началом выполнения команды, частью которой является.
        В данном примере переменная var2 увеличилась на 
        единицу перед выводом в консоль с помощью cout.

        В свою очередь, постфиксный ин(де)кремент выполняется
        после выполнения команды. То есть, переменная var1
        уменьшилась на единицу (стала девяткой) только после
        вывода на консоль старого значения var1.
    */

    var1 = 10; var2 = 5;
    cout << var1++ + var1++ + ++var2 << endl;  
    cout << var1 << " " << var2 << "\n\n\n"; 
    //разберитесь, почему выводятся именно 26, 12 и 6 

    return 0;
}